
#pragma warning (disable : 4996)

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#define BUFFER_SIZE 80

int main()
{
	char* words[1000];
	char* tmpStr;
	int num = 0, tmpNum = 0, tmpNumSecond = 0;
	char buffer[BUFFER_SIZE], tmp[BUFFER_SIZE] = { NULL, }, arr[BUFFER_SIZE + 1];
	char tmpSecond[BUFFER_SIZE] = { NULL, };
	int doubleCount = 0, countArr[1000] = { 0 }, countTemp;
	bool isDouble = false;

	FILE* fp = fopen("pride_and_prejudice_test.txt", "r");

	if (fp == NULL)
	{
		printf("Open failed.\n");
		return 1;
	}

	while (fgets(buffer, BUFFER_SIZE, fp) != NULL)
	{
		// 소문자로
		for (int i = 0; i < strlen(buffer); i++)
		{
			if (buffer[i] == '\0')
				break;

			else if (isalpha(buffer[i]) != 0)
			{
				if (islower(buffer[i]) == 0)
					buffer[i] = tolower(buffer[i]);
			}
		}

		buffer[strlen(buffer) - 1] = '\0';

		char* ptr = strtok(buffer, " ");

		while (ptr != NULL)
		{
			int length = strlen(ptr);

			strcpy(arr, ptr);

			for (int i = 0; i < length; i++)
			{
				if (i > 1 && isalpha(arr[i - 2]) == 0 && isalpha(arr[i - 1]) == 0 && isalpha(arr[i]) != 0)
				{
					isDouble = true;
				}

				if (i > 0 && i < length - 1 && 
					((isalpha(arr[i - 1]) != 0) && (isalpha(arr[i]) == 0)) &&
					((isalpha(arr[i]) == 0) && (isalpha(arr[i + 1]) != 0)) ||
					(isalpha(arr[i]) != 0) && isDouble == false)
				{
					tmp[tmpNum] = arr[i];
					tmpNum++;
				}

				if (isDouble == true && isalpha(arr[i]) != 0)
				{
					tmpSecond[tmpNumSecond] = arr[i];
					tmpNumSecond++;
				}

				/*else if (i > 0 && isalpha(arr[i - 1]) == 0 && isalpha(arr[i]) == 0)
				{
					doubleCount++;
					isDouble = true;
				}

				if (doubleCount >= 2)
				{
					tmpSecond[tmpNumSecond] = arr[i];
					tmpNumSecond++;
					continue;
				}*/

				/*if (!isDouble)
				{
					tmp[tmpNum] = arr[i];
					tmpNum++;
				}*/
			}

			if (strlen(tmp) >= 7)
			{
				countArr[num]++;
				words[num] = strdup(tmp);
				num++;

				
			}

			if (strlen(tmpSecond) >= 7)
			{
				countArr[num]++;
				words[num] = strdup(tmpSecond);
				num++;
			}



			for (int i = 0; i < num; i++)
			{
				for (int j = i + 1; j < num; j++)
				{
					if (strcmp(words[j], words[i]) == 0)
					{
						// 새로운변수 k를 안해주면 3개이상의 중복된단어를 잡아낼수없음.
						int k = j;

						countArr[i]++;

						// 중복된거 찾은지점부터 앞으로땡긴다.
						for (; k < num - 1; k++)
						{
							words[k] = words[k + 1];
						}
						num--;
					}
				}
			}

			ptr = strtok(NULL, " ");

			// 초기화
			for (int i = 0; i < tmpNum; i++)
			{
				tmp[i] = NULL;
			}

			for (int i = 0; i < tmpNumSecond; i++)
			{
				tmpSecond[i] = NULL;
			}

			tmpNum = 0;
			tmpNumSecond = 0;
			isDouble = false;
		}
		
	}

	fclose(fp);

	// 정렬
	for (int step = 0; step < num - 1; step++)
	{
		for (int i = 0; i < num - 1 - step; i++)
		{
			if (strcmp(words[i], words[i + 1]) > 0)
			{
				tmpStr = words[i];
				words[i] = words[i + 1];
				words[i + 1] = tmpStr;

				countTemp = countArr[i];
				countArr[i] = countArr[i + 1];
				countArr[i + 1] = countTemp;
			}
		}
	}

	// Debug Assertation Failed c >= -1 && c <= 255
	// " <- 이것땜에 오류남

	for (int i = 0; i < num; i += 1)
	{
		printf("%s %d\n", words[i], countArr[i]);
	}

	return 0;
}

