
// ctrl + h 글자변경

#pragma warning (disable : 4996)

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define BUFFER_SIZE 100
#define WORD_SIZE 2500

int num = 0; // number of strings
int resultNum = 0;
char* words[WORD_SIZE];
char* result[WORD_SIZE];
int countArr[WORD_SIZE] = { 0 };

void Input();
int crop_and_tolower(char* str);
void Output();
void Sort();
void CatchDup();
void Delim(char* arr);

int main()
{
	Input();
	Sort();
	CatchDup();
	Output();

	return 0;
}

void Input()
{
	char buffer[BUFFER_SIZE];

	FILE* fp = fopen("pride_and_prejudice.txt", "r");

	if (fp == NULL)
	{
		printf("Open failed.\n");
		return;
	}

	while (fscanf(fp, "%s", buffer) != EOF)
	{
		int len = crop_and_tolower(buffer);

		if (len == -1)
		{
			Delim(buffer);
		}

		if (len >= 7)
		{
			words[num] = strdup(buffer);
			num++;
		}
	}

	fclose(fp);
}

void CatchDup()
{
	int i = 0, count = 0;

	// 새로운배열에 복사한다.
	// 근데 왜 한칸앞으로땡기는건 한 700줄까진 되는데 그 이후론 안될까?
	while (i < num - 1)
	{
		if (strcmp(words[i], words[i + 1]) != 0)
		{
			result[resultNum] = words[i];
			countArr[resultNum] = count;
			resultNum++;
			i++;
			count = 0;
		}

		else
		{
			count++;
			i++;
		}
	}
}

void Delim(char* arr)
{
	int tmpNum = 0, tmpNumSecond = 0;
	char tmp[BUFFER_SIZE] = { '\0', };
	char tmpSecond[BUFFER_SIZE] = { '\0', };

	int front = 0, back = 0;

	bool isDouble = false;

	int length = strlen(arr);

	for (int i = 0; i < length; i++)
	{
		if (i > 1 && isalpha(arr[i - 2]) == 0
			&& isalpha(arr[i - 1]) == 0 && isalpha(arr[i]) != 0)
		{
			isDouble = true;
		}

		if ((i > 0 && i < length - 1 &&
			isalpha(arr[i - 1]) != 0 && 
			isalpha(arr[i]) == 0 &&
			isalpha(arr[i]) == 0 && 
			isalpha(arr[i + 1]) != 0) ||
			(isalpha(arr[i]) != 0 && 
			isDouble == false))
		{
			tmp[tmpNum] = tolower(arr[i]);
			tmpNum++;
		}

		if (isDouble == true && isalpha(arr[i]) != 0)
		{
			tmpSecond[tmpNumSecond] = tolower(arr[i]);
			tmpNumSecond++;
		}
	}

	if (strlen(tmp) >= 7)
	{
		words[num] = strdup(tmp);
		num++;
	}

	if (strlen(tmpSecond) >= 7)
	{
		words[num] = strdup(tmpSecond);
		num++;
	}

	// 초기화
	for (int i = 0; i < tmpNum; i++)
	{
		tmp[i] = '\0';
	}

	for (int i = 0; i < tmpNumSecond; i++)
	{
		tmpSecond[i] = '\0';
	}

	tmpNum = 0;
	tmpNumSecond = 0;
	isDouble = false;
}

int crop_and_tolower(char* str)
{
	int len = strlen(str);

	for (int i = 0; i < len; i++)
	{
		if (i > 1 && isalpha(str[i - 2]) == 0
			&& isalpha(str[i - 1]) == 0 && isalpha(str[i]) != 0)
		{
			return -1;
		}
	}

	int s = 0, t = len - 1;

	while (s < len && !isalpha(str[s]))
		s++;

	while (t >= 0 && !isalpha(str[t]))
		t--;

	if (s > t)
		return 0;

	int k = 0;

	for (int i = s; i <= t; i++)
		str[k++] = tolower(str[i]);

	str[t - s + 1] = '\0';

	return t - s + 1;
}

void Output()
{
	for (int i = 0; i < resultNum; i += 10)
	{
		printf("%s %d\n", result[i], countArr[i] + 1);
	}
}

void Sort()
{
	char* tmp;

	for (int i = num - 1; i >= 0; i--)
	{
		for (int j = 0; j < i; j++)
		{
			if (strcmp(words[j], words[i]) > 0)
			{
				tmp = words[i];
				words[i] = words[j];
				words[j] = tmp;
			}
		}
	}
}